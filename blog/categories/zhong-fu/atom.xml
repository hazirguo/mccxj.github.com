<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 重复 | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/zhong-fu/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2013-03-10T22:33:16+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[improve bitter code: 对付魔鬼数字]]></title>
    <link href="http://mccxj.github.com/blog/20120731_improve-bitter-code-6.html"/>
    <updated>2012-07-31T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/improve-bitter-code-6</id>
    <content type="html"><![CDATA[<p><strong>备注: 示例中的代码并不是真实代码的完全拷贝</strong></p>

<h3>道高一尺，魔高一丈</h3>

<p>魔鬼数字在项目中大量出现，是代码可读性维护性变差的重要推手。
为了控制事态恶化，项目中加入findbugs，checkstyle等静态检查工具，试图让人自觉修复魔鬼数字这类头疼的问题。</p>

<p>最近在review N项目的代码时，发现有新童鞋对修复checkstyle的问题热情高涨，有些修改的确是有益的，
但是对魔鬼数字的修改就显得不是正路了。大家先看看：
{% highlight java %}
private static final int INT_2 = 2;
private Static final int INT_80 = 80;
private Static final int INT_1000 = 1000;
private Static final int INT_60000 = 60000;
{% endhighlight %}</p>

<p>这种情况以前也出现过，那个时候刚推广checkstyle，结果有人定义了NumberUtil类，里边就有ONE, TWO...等变量，
一直延伸到好几十。这让我非常纠结，劝说了很多次，结果这个类最终还是扎下根来了。我对此深恶痛绝。</p>

<p>今天再次看到这种方式，真是道高一尺魔高一丈呀。我又要发牢骚了。</p>

<h3>认清工具的本质</h3>

<p>这种做法完全就是为了对付checkstyle，而不是对付那对问题代码。工具本来是想提醒程序员，避免写出难以维护的代码。
结果我们更聪明，把代码藏起来，眼不见为净。这样其实是把数字和变量名直接关联起来了，
你能想象一个叫INT_2的变量值确是1么? 如果在不同含义的逻辑里边使用这样一个魔鬼变量，
一旦值发生变化，就会顺带把不应该修改的地方也改动了。</p>

<p>如果我们真的是为了提高自己的编码水平，提高项目的代码质量，就应该认真的对待这些魔鬼数字。
对于魔鬼数字，应该有一个良好的命名，对于经常出现的，还应该找个合适的地方加以管理。接下来以上面的例子继续分析。</p>

<h3>解决魔鬼数字</h3>

<p>要解决魔鬼数字，首先是认清魔鬼数字代表的意义，给它起一个合适的名字。</p>

<p>查看源代码，可以发现，做了下面的代码调整：</p>

<ol>
<li>2是某个值在列表中的位置索引，换成XXX_IDX</li>
<li>80是http的默认端口，换成DEFAULT_HTTP_PROT</li>
<li>1000是用来把秒换成毫秒的，可以用MILLISECONDS_PER_SECOND</li>
<li>60000是默认超时时间来的，换成DEFAULT_TIMEOUT</li>
</ol>


<p>同样，经常会看到魔鬼字符串，"0","1"这样的值出现代码里边，也应该
把给他们起一个好的名字，例如作为执行结果，有SUCCESS、FAILED等。</p>

<h3>更进一步</h3>

<p>需要考虑的还有常量定义的地方，另外考虑使用方法封装来处理魔鬼数字的逻辑。
这样可以隐藏一些细节，把作用域限制在很小的地方。
例如下面经常出现的魔鬼字符串，就可以考虑把整个判断逻辑封装到user类里边去，
而不只是简单的定义出ACTIVE这样一个常量。
{% highlight java %}
// 原有的代码
if("1".equals(user.getStatus())){</p>

<pre><code>// ...
</code></pre>

<p>}</p>

<p>// 改造后,"1"作为user的常量使用于isActive方法
if(user.isActive()){</p>

<pre><code>// ...
</code></pre>

<p>}
{% endhighlight %}</p>

<p>不过话说回来，解决魔鬼数字、字符串之类等'小枝小节'，花费的精力不小。
但不要忽视这些细节，这样可以让自己不断提高对代码的认识，也便于其他人维护你的代码。</p>

<p>对付魔鬼数字，还是不要走捷径的好！</p>

<p>{% assign series_list = "improve bitter code" %}
{% include series_list.html %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[improve bitter code: '不可避免'的重复]]></title>
    <link href="http://mccxj.github.com/blog/20120729_improve-bitter-code-4.html"/>
    <updated>2012-07-29T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/improve-bitter-code-4</id>
    <content type="html"><![CDATA[<p><strong>备注: 示例中的代码并不是真实代码的完全拷贝</strong></p>

<h3>一段分批处理的逻辑</h3>

<p>周六做code diff的时候发现B项目一段颇长的处理逻辑(40行左右)。处理流程是这样的，
从页面上取到一批数据之后，用这批数据封装参数进行后台调用(远程调用)。为了避免数据调用超时，
对这批数据进行分批多次调用。代码如下所示(现实的代码比这个要复杂些，并且没有使用subList方法)：
{% highlight java %}
List batchdatas = ...;
int batchsize = 10; // load from parameter</p>

<p>int datasize = batchdatas.size();
if(datasize > batchsize){</p>

<pre><code>int batch = datasize / batchsize;
for(int i=0;i&lt;batch;i++){
    List inparams = new ArrayList();
    List batchdata = batchdatas.subList(batchsize*i, batchsize*(i+1));
    inparams.add(new CEntityList(batchdata));
    RemoteCall.commonInvoke(operator, inparams, "CheckCmd");
}

int left = datasize % batchsize;
if(left != 0){
    List inparams = new ArrayList();
    List batchdata = batchdatas.subList(batchsize*batch, datasize);
    inparams.add(new CEntityList(batchdata));
    RemoteCall.commonInvoke(operator, inparams, "CheckCmd");
}
</code></pre>

<p>}
else {</p>

<pre><code>List inparams = new ArrayList();
inparams.add(new CEntityList(batchdatas));
RemoteCall.commonInvoke(operator, inparams, "CheckCmd");
</code></pre>

<p>}
{% endhighlight %}</p>

<p>从代码的实现看，思路还是比较清晰的。如果不足一次，就一次提交。否则计算出一共要分多少次，
然后逐次处理提交，最后还要判断是否还有剩余的，如果有就再处理一次。</p>

<p>代码显现出来的问题也比较明显，就是远程调用的逻辑出现了重复。</p>

<h3>算法小调整，避免重复</h3>

<p>有没什么办法可以避免重复? 或许有些童鞋第一反应是给这几句代码抽取成小方法。
不过这里有更好的办法，首先细想一下就会发现不足一次的判断(datasize > batchsize)不是必要的，
如果计算批次而是计算每次的起始点和结束点，上面两个分支也可以合并一下。调整后代码如下：
{% highlight java %}
List batchdatas = ...;
int batchsize = 10; // load from parameter</p>

<p>int datasize = batchdatas.size();
for(int startidx=0;startidx&lt;datasize;startidx+=batchsize){</p>

<pre><code>int endidx = (startidx+batchsize) &gt; datasize ? datasize : (startidx+batchsize);

List inparams = new ArrayList();
List batchdata = batchdatas.subList(startidx, endidx);
inparams.add(new CEntityList(batchdata));
RemoteCall.commonInvoke(operator, inparams, "CheckCmd");
</code></pre>

<p>}
{% endhighlight %}</p>

<p>其中计算endidx使用了一个三元表达式，使用三元表达式用来替代一些简单的if-else语句是个实用的小技巧。
代码量缩小为原来的三分之一，代码少了，维护量也轻松了。</p>

<p>类似这样的代码也并不少见，例如计算总页数的分页逻辑有下面的写法
{% highlight java %}
// 常用做法
int totalpage = totalsize / pagesize;
if(totalsize % pagesize != 0){</p>

<pre><code>totalpage++;
</code></pre>

<p>}</p>

<p>// 另外一种写法
int totalpage = (totalsize + pagesize - 1) / pagesize;
{% endhighlight %}</p>

<h3>基本功很重要</h3>

<p>java是一门比较古板的语言，大多数情况下，写出来的代码也是大同小异的。
同时，java相关框架又特别的多，很容易拣了芝麻丢了西瓜。
以来面试的童鞋为例，连基本算法的时间复杂度都没弄清楚的人不在少数，所以
在项目代码中，经常看到化简为繁的代码，现在也很习惯了。</p>

<p>{% assign series_list = "improve bitter code" %}
{% include series_list.html %}</p>
]]></content>
  </entry>
  
</feed>
