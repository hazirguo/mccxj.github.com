<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 函数式 | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/han-shu-shi/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2013-03-10T22:33:16+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hello erlang, part 2]]></title>
    <link href="http://mccxj.github.com/blog/20120715_hello-erlang-2.html"/>
    <updated>2012-07-15T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/hello-erlang-2</id>
    <content type="html"><![CDATA[<h3>练习重点</h3>

<ol>
<li>依然是熟悉erlang匹配模式的编程方式，对于用习惯了判断，循环操作的人来说，这个变化很大</li>
<li>熟悉erlang列表操作</li>
<li>为后面学习高阶函数fun，还有更多高级数据类型打好基础</li>
</ol>


<h3>练习1:压缩有序列表</h3>

<p>类似搜索里边的倒排索引，需要对词对应的文档列表进行存放。
在这里，我们将一个有序列表转换成另外一种形式，如
{% highlight erlang %}
%% 原始形式
[1,1,2,4,5,6,6,98,100,101,102,102].
%% 最终形式
[{1,2},{4,6},{98,98},{100,102}].
{% endhighlight %}</p>

<h3>示例代码</h3>

<p>{% highlight erlang %}
multi(L) -> lists:reverse(multi_local(L, [])).
multi_local([], R) -> R;
multi_local([H|L], R) -></p>

<pre><code>{LL, E} = multi_r(L, H),
multi_local(LL, [{H, E}|R]).
</code></pre>

<p>%% 获取L里边里边和H同属一组的最后一个数,同时返回剩余的列表
%% 如果L以H开头，表示出现重复数
%% 如果L以H+1开头，表示出现序列数
multi_r(L, H) -></p>

<pre><code>N = H + 1,
case L of
    [H|LL] -&gt; multi_r(LL, H);
    [N|LL] -&gt; multi_r(LL, N);
    [] -&gt; {[], H};
    _ -&gt; {L, H}
end.
</code></pre>

<p>{% endhighlight %}</p>

<h3>效率问题</h3>

<p>这里和上次不一样的是，这里没有使用lists:append方法，而是在最后使用了reverse.</p>

<p>{% highlight erlang %}
<a href="20120712_horse-riding-chessboard.html">1</a> ++ [2, 3].
lists:append(<a href="20120712_horse-riding-chessboard.html">1</a>, [2, 3]).
lists:reverse([3|[2, 1]]).
{% endhighlight %}
上面三种方式得到的结果是一样的。前面两种，每增加一个元素，都会遍历左边的列表，所以在递归里边处理的话，
效率并不好。把元素添加到表头，在递归完成后进行反转，效果就会好些。</p>

<h3>练习2:马踏棋盘</h3>

<p>作为一个阶段的学习总结，对<a href="20120712_horse-riding-chessboard.html">马踏棋盘的算法思考</a>用erlang实现。</p>

<p>代码比较悲剧，我选择了array，用了一些fun函数，从这么个例子就可以看出，自己还没掌握好erlang惯用法。
感觉数据结构没有选好，并且用了命令语言的一些编程思路，有些东西或许可以用列表解析来弄，
等再掌握多一些东西，再回头来体会一把!
{% highlight erlang %}
-module(horse).</p>

<p>%% Exported Functions
-export([walkboard/0]).</p>

<p>%% API Functions
walkboard() ->
  %% lists:foreach(fun(I) -> lists:foreach(fun(J) -> walkboard({I, J}) end, lists:seq(0,7)) end, lists:seq(0,7)).
  walkboard({2,3}).</p>

<p>walkboard({I,J}) ->
  {ARR, PATH, POSS} = init(),
  catch walk(0, setvalue({I, J}, 1, ARR), array:set(0, {I,J}, PATH), POSS).</p>

<p>walk(63, <em>, PATH, </em>) -> throw(PATH);
walk(MARK, ARR, PATH, POSS) ->
  {IP, JP} = array:get(MARK, PATH),
  WC = fun({I,J,_}) -></p>

<pre><code>     walk(MARK+1, setvalue({I+IP,J+JP}, 1, ARR), array:set(MARK+1, {I+IP,J+JP}, PATH), POSS)
   end,
</code></pre>

<p>  lists:foreach(WC, filter(MARK, PATH, POSS, ARR)).</p>

<p>%%
%% Local Functions
%%
init() ->
  ARR = array:new(8, {default,array:new(8, {default,0})}),
  PATH = array:new(64),
  POSS = [{-2, 1}, {2, 1}, {1, 2}, {-1, 2}, {2, -1}, {-2, -1}, {-1, -2}, {1, -2}],
  {ARR, PATH, POSS}.</p>

<p>filter(MARK, PATH, POSS, ARR) ->
  {I, J} = array:get(MARK, PATH),
  Fun1 = fun({IP, JP}) -></p>

<pre><code>       {IXP, JXP} = {I+IP, J+JP},
       case valid({IXP, JXP}, ARR) of
         false -&gt; {IP, JP, -1};
         true -&gt; 
         %% 计算空点数
         CAL = fun({IP2, JP2}, Sum) -&gt; 
                 case valid({IXP+IP2, JXP+JP2}, ARR) of
                   true -&gt; 1 + Sum;
                   false -&gt; Sum
                 end
               end,
               {IP, JP, lists:foldl(CAL, 0, POSS)}
       end
     end,
</code></pre>

<p>  %% 最后进行排序
  T = lists:map(Fun1, POSS),
  S = lists:filter(fun({<em>, </em>, Z}) -> Z == 0 end, T),
  LEN = length(S),
  if</p>

<pre><code>LEN &gt; 1 -&gt; [];
LEN &gt; 0 -&gt; S;
true -&gt; SS = lists:filter(fun({_, _, Z}) -&gt; Z &gt;= 0 end, T),
    lists:sort(fun({_, _, Z1}, {_, _, Z2}) -&gt; Z1 &lt; Z2 end, SS)
</code></pre>

<p>  end.</p>

<p>valid({I,J}, ARR) ->
  I >= 0 andalso I<8 andalso J>=0 andalso J&lt;8 andalso getvalue({I,J}, ARR) == 0.</p>

<p>getvalue({I,J}, ARR) ->
  array:get(J, array:get(I, ARR)).</p>

<p>setvalue({I,J}, VAL, ARR) ->
  array:set(I, array:set(J, VAL, array:get(I, ARR)), ARR).
{% endhighlight %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hello erlang, part 1]]></title>
    <link href="http://mccxj.github.com/blog/20120714_hello-erlang-1.html"/>
    <updated>2012-07-14T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/hello-erlang-1</id>
    <content type="html"><![CDATA[<h3>练习重点</h3>

<ol>
<li>erlang是单赋值的，就好像都经过java里边的final修饰过</li>
<li>erlang没有内置的循环结构，这个和大多数语言是不一样的</li>
<li>erlang是函数式语言，需要理解模式匹配编程方式</li>
<li>erlang经常会遇到递归, 并且支持尾递归函数调用</li>
</ol>


<h3>练习1:数据库demo</h3>

<p>作为学习erlang里边的模式匹配，熟悉语法。
编写一个数据库模块db.erl，它能够存储、检索、删除元素。我们需要实现的接口有:
{% highlight erlang %}
db:new()                   %% Db.
db:destroy(Db)             %% ok.
db:write(Key, Element, Db) %% NewDb.
db:delete(Key, Db)         %% NewDb.
db:read(Key, Db)           %% {ok, Element} | {error, instance}.
db:match(Element, Db)      %% [Key1, ..., KeyN].
{% endhighlight %}</p>

<h3>实现代码</h3>

<p>{% highlight erlang %}
-module(db).</p>

<p>%% Exported Functions
-export([new/0, write/3, read/2, match/2, delete/2, destroy/1]).</p>

<p>%% API Functions
new() -> [].
destroy(_) -> ok.
write(Key, Element, DB) -> [{Key,Element}|DB].
delete(Key, DB) -> delete_local(Key, DB, []).
read(Key, DB) -></p>

<pre><code>case DB of
    [{Key, Element}|_] -&gt; {oKey, Element};
    [_|ODB] -&gt; read(Key, ODB);
    _ -&gt; {error, instance}
end.
</code></pre>

<p>match(Element, DB) -> match_local(Element, DB, []).</p>

<p>%% Local Functions
match_local(Element, DB, LIST) -></p>

<pre><code>case DB of
    [{Key, Element}|ODB] -&gt; match_local(Element, ODB, [Key|LIST]);
    [_|ODB] -&gt; match_local(Element, ODB, LIST);
    _ -&gt; LIST
end.
</code></pre>

<p>delete_local(Key, DB, NDB) -></p>

<pre><code>case DB of
    [{Key, _}|ODB] -&gt; delete_local(Key, ODB, NDB);
    [H|ODB] -&gt; delete_local(Key, ODB, [H|NDB]);
    _ -&gt; NDB
end.
</code></pre>

<p>{% endhighlight %}</p>

<p>当然，case语句同样可以用如下代码替代：其中第三行的Key因为没有使用就换成<em>,
不然会提示警告variable 'Key' is unused。
{% highlight erlang %}
delete_local(Key, [{key, </em>}|ODB], NDB) -> delete_local(Key, ODB, NDB);
delete_local(Key, [H|ODB], NDB) -> delete_local(Key, ODB, [H|NDB]);
delete_local(<em>, </em>, NDB) -> NDB;
{% endhighlight %}</p>

<h3>练习2:排序算法</h3>

<p>下面练习一下快速排序和归并排序，再熟悉一下模式匹配和递归的写法。
{% highlight erlang %}
-module(sort).
-export([quicksort/1, mergesort/1]).</p>

<p>%% 快速排序
quicksort([H|Tail]) -></p>

<pre><code>lists:append([quicksort(lists:filter(fun(X) -&gt; X &lt; H end, Tail)), 
              [H], 
              quicksort(lists:filter(fun(X) -&gt; X &gt;= H end, Tail))]);
</code></pre>

<p>quicksort(L) -> L.</p>

<p>%% 归并排序
mergesort(A) -></p>

<pre><code>case length(A) of
    0 -&gt; [];
    1 -&gt; A;
    LEN -&gt; M = length(A) div 2,
           merge(mergesort(lists:sublist(A, 1, M)), 
                 mergesort(lists:sublist(A, M + 1, LEN - M)), [])
end.
</code></pre>

<p>merge(A, [], L) -> lists:append([L, A]);
merge([], B, L) -> lists:append([L, B]);
merge([HA|TA], [HB|TB], L) -></p>

<pre><code>if
    HA &gt; HB -&gt; merge([HA|TA], TB, lists:append([L, [HB]]));
    true -&gt; merge(TA, [HB|TB], lists:append([L, [HA]]))
end.
</code></pre>

<p>{% endhighlight %}</p>
]]></content>
  </entry>
  
</feed>
