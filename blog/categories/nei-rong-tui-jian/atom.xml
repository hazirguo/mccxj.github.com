<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 内容推荐 | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/nei-rong-tui-jian/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2013-03-10T22:33:16+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Node.js Best practices]]></title>
    <link href="http://mccxj.github.com/blog/20130102_nodejs-best-practices.html"/>
    <updated>2013-01-02T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/nodejs-best-practices</id>
    <content type="html"><![CDATA[<p><strong>完整的ppt来源于<a href="http://www.slideshare.net/the_undefined/nodejs-best-practices-10428790">Node.js Best practices</a>,作者<a href="http://www.slideshare.net/the_undefined">Felix Geisendörfer</a>,需翻越</strong></p>

<h3>Callbacks</h3>

<p>下面是关于解析json文件的示例代码:
{% highlight javascript %}
var fs = require('fs);
function readJSON(path, cb){
  fs.readFile(path, 'utf8', function(err, data){</p>

<pre><code>cb(JSON.parse(data));
</code></pre>

<p>  }
}
{% endhighlight %}</p>

<p>显然，上面的代码没有处理异常情况，因此再加个异常处理逻辑上去:
{% highlight javascript %}
var fs = require('fs);
function readJSON(path, cb){
  fs.readFile(path, 'utf8', function(err, data){</p>

<pre><code>if(err) return cb(err);
cb(JSON.parse(data));
</code></pre>

<p>  }
}
{% endhighlight %}</p>

<p>还没有结束，我们还没考虑到文件内容不是json这种情况，会导致parse出现异常，因此再处理一下：
{% highlight javascript %}
var fs = require('fs);
function readJSON(path, cb){
  fs.readFile(path, 'utf8', function(err, data){</p>

<pre><code>if(err) return cb(err);
try{
  cb(JSON.parse(data));
}catch(err){
  cb(err);
}
</code></pre>

<p>  }
}
{% endhighlight %}</p>

<p>对于cb来说，仍然无法区分正常结果和异常内容，这个问题通常可以通过增加一个err参数来处理，如:
{% highlight javascript %}
var fs = require('fs);
function readJSON(path, cb){
  fs.readFile(path, 'utf8', function(err, data){</p>

<pre><code>if(err) return cb(err);
try{
  var json = JSON.parse(data);
}catch(err){
  return cb(err);
}
cb(null, json);
</code></pre>

<p>  }
}
{% endhighlight %}</p>

<p><strong>这个示例告诉我们，对于callback，需要时刻准备应付正常结果和异常情况的处理。</strong></p>

<p>再来看看另外一个常见错误:
{% highlight javascript %}
function readJSONFiles(files, cb){
  var results = {};
  var remaining = files.length;</p>

<p>  files.forEach(function(file){</p>

<pre><code>readJSON(file, function(err, json){
  if(err) return cb(err);

  results[file] = json;
  if(!--remaining) cb(null, results);
}
</code></pre>

<p>  });
}
{% endhighlight %}</p>

<p>这里隐含了一个常见的场景:<strong>批量处理时，任意一个失败，及时退出</strong>。有时候可以用标识符，这里采用另外一种手法：<strong>重置回调方法</strong>。
{% highlight javascript %}
function readJSONFiles(files, cb){
  var results = {};
  var remaining = files.length;</p>

<p>  files.forEach(function(file){</p>

<pre><code>readJSON(file, function(err, json){
  if(err){
    cb(err);
    cb = function(){};
    return;
  }

  results[file] = json;
  if(!--remaining) cb(null, results);
}
</code></pre>

<p>  });
}
{% endhighlight %}</p>

<h3>Nested Callbacks</h3>

<p>先看看一个恐怖的例子:
{% highlight javascript %}
db.query('SELECT A ...', function(){
  db.query('SELECT B ...', function(){</p>

<pre><code>db.query('SELECT C ...', function(){
  db.query('SELECT D ...', function(){
  });
});
</code></pre>

<p>  });
});
{% endhighlight %}</p>

<p>活生生就是一个怪物:)，多层嵌套的回调不是很好的风格，我们需要一些流程控制的东西来辅助，例如Control Flow Libs:
{% highlight javascript %}
var async = require('async');</p>

<p>async.series({
  queryA: function(next){</p>

<pre><code>db.query('SELECT A ...', next);
</code></pre>

<p>  },
  queryB: function(next){</p>

<pre><code>db.query('SELECT B ...', next);
</code></pre>

<p>  },
  queryA: function(next){</p>

<pre><code>db.query('SELECT C ...', next);
</code></pre>

<p>  }
  // ...
}, function(err, results){
  //...
});
{% endhighlight %}</p>

<p>像上面的代码，最明显的地方就是异常处理被完全隔离出来。<strong>如果要把代码分布到很多小方法里边的话，Node.js的确不是很容易做到</strong>。</p>

<h3>Exceptions</h3>

<p>通常throw new Error(msg)可以让你的程序进行异常退出，并在控制台上输入错误信息和堆栈信息。</p>

<p>但有时候我们要考虑的是，<strong>一些未知的bug</strong>，例如下面一个有bug的示例:
{% highlight javascript %}
function MyClass(){}</p>

<p>MyClass.prototype.myMethod = function(){
  setTimeout(function(){</p>

<pre><code>this.myOtherMethod();
</code></pre>

<p>  }, 10);
}</p>

<p>MyClass.prototype.myOtherMethod = function(){};</p>

<p>(new MyClass).myMethod();
{% endhighlight %}</p>

<p>我们可以采用Global Catch的方式:
{% highlight javascript %}
process.on('uncaughtException', function(err){
  console.err('uncaught exception: ' + err.stack);
});
{% endhighlight %}</p>

<p>更好的处理方式是:<strong>进程挂了，认栽了，到更高层面上去处理</strong>。
{% highlight javascript %}
process.on('uncaughtException', function(err){
  // You could use node-airbake for this
  sendErrorToLog(function(){</p>

<pre><code>// Once the error was logged, kill the process
console.err(err.stack);
process.exit(1);
</code></pre>

<p>  }
});
{% endhighlight %}</p>

<h3>Deployment</h3>

<p>比较初级的方式是采用node直接运行或在后台运行。老手可能会采用一个脚本来搞:
{% highlight bash %}</p>

<h1>! /bin/bash</h1>

<p>while :
do
  node server.js
  echo "Server crashed!"
  sleep 1
done
{% endhighlight %}</p>

<p>专家级采用的方式可能是(借助成熟的集成工具):
{% highlight bash %}</p>

<h1>!upstart</h1>

<p>description "myapp"
author "felix"</p>

<p>start on(local-filesystems and net-device-up IFACE=eth0)
stop on shutdown</p>

<p>respawn # restart when job dies
respawn limit 5 60 # give up restart after 5 respawns in 60 seconds</p>

<p>script
  exec sudo -u www-data /path/to/server.js >> /var/log/myapp.log 2>&amp;1
end script
{% endhighlight %}</p>

<p>当然，还有些创新风格的(基于托管平台的):
{% highlight bash %}
$git push joyent master
$git push nodejitsu master
$git push heroku master
{% endhighlight %}</p>

<p><strong>没有托管平台的话，借助成熟的工具应该是最好的选择，性价比高。</strong></p>
]]></content>
  </entry>
  
</feed>
