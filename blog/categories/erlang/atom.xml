<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: erlang | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/erlang/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2013-03-10T22:33:16+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hello erlang, part 4]]></title>
    <link href="http://mccxj.github.com/blog/20120721_hello-erlang-4.html"/>
    <updated>2012-07-21T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/hello-erlang-4</id>
    <content type="html"><![CDATA[<h3>练习重点</h3>

<p>列表解析和高阶函数是erlang的基本用法之一，熟练掌握还是很有必要的。
作为一个阶段的学习总结，按照书上的一个练习题，尝试实现列表模块中的一些方法。</p>

<h3>后续学习计划</h3>

<p>再找时间总结一下位匹配用法，然后就开始客户端服务器编程模型，
网络和分布式方面的内容。</p>

<p>相关内容虽然都看过一下，但是没有敲过代码，感觉心里没底。还是那个硬道理：纸上得来终觉浅呀。</p>

<h3>简单的测试用例</h3>

<p>作为另外一个章节的内容，单元测试。我顺便实践一下erlang的单元测试框架eunit，
里边使用了宏来作为assert语句(使用eclipse插件可以有很好的提示)，
总的来说，xunit的基本风格都差不多，注意import eunit的包，方法名采用_test结束。
执行的时候调用模块的test方法就可以了。我简单写了一些测试用例:</p>

<p>{% highlight erlang %}
-module(myliststest).
-include_lib("eunit/include/eunit.hrl").
-import_all(mylists).</p>

<p>%% EUnit TestCase</p>

<p>%% all/2
all_empty_test() ->
  ?assert(mylists:all(fun(E) -> E > 10 end, [])).
all_test() ->
  ?assertNot(mylists:all(fun(E) -> E > 10 end, [11,12,10])).</p>

<p>%% any/2
any_empty_test() ->
  ?assertNot(mylists:any(fun(E) -> E > 10 end, [])).
any_test() ->
  ?assert(mylists:any(fun(E) -> E > 10 end, [11,12,10])).</p>

<p>%% append/1
append_1_test() ->
  ?assertEqual([1,2,3,a,b,4,5,6], mylists:append([[1, 2, 3], [a, b], [4, 5, 6]])).</p>

<p>%% append/2
append_2_test() ->
  ?assertEqual("abcdef", mylists:append("abc", "def")).</p>

<p>%% delete/2
delete_test() ->
  ?assertEqual([1,2,4], mylists:delete(3, [1,2,3,4])).</p>

<p>%% dropwhile/2
dropwhile_test() ->
  ?assertEqual([1,2], mylists:dropwhile(fun(E) -> E >= 3 end, [1,2,3,4])).</p>

<p>%% duplicate/2
duplicate_test() ->
  ?assertEqual([x, x], mylists:duplicate(2, x)).</p>

<p>%% filter/2
filter_test() ->
  ?assertEqual([3,4], mylists:filter(fun(E) -> E >= 3 end, [1,2,3,4])).</p>

<p>%% reverse/1
reverse_test() ->
  ?assertEqual([4,3,2,1], mylists:reverse([1,2,3,4])).</p>

<p>%% min/1
min_test() ->
  ?assertEqual(2, mylists:min([3,4,2,5])).</p>

<p>%% zip/2
zip_2_test() ->
  ?assertEqual([{1,3},{2,4}], mylists:zip([1,2], [3,4,5])).</p>

<p>%% zip/3
zip_3_test() ->
  ?assertEqual([{1,3,5},{2,4,7}], mylists:zip3([1,2], [3,4,5], [5,7])).</p>

<p>%% zipwith/3
zipwith_test() ->
  ?assertEqual([5,7,9], mylists:zipwith(fun(X, Y) -> X+Y end, [1,2,3], [4,5,6])).</p>

<p>%% zipwith/4
zipwith3_test() ->
  ?assertEqual([[a,x,1],[b,y,2],[c,z,3]], mylists:zipwith3(fun(X, Y, Z) -> [X,Y,Z] end, [a,b,c], [x,y,z], [1,2,3])).
{% endhighlight %}</p>

<h3>示例代码</h3>

<p>根据上面的测试用例，我写了实现代码，如下所示。注意的时候，我偷懒使用了export_all,
但是min/2好像默认有一个已经被引入了，所以需要去除这个模块。就export_all本身来说，
也不是推荐方式，还是应该严格区分public api和local api。
{% highlight erlang %}
-module(mylists).
-compile(export_all).
-compile({no_auto_import,[min/2]}).</p>

<p>%% all/2
all(_P, []) ->
  true;
all(P, [H|T]) ->
  case P(H) of</p>

<pre><code>true -&gt; all(P, T);
false -&gt; false
</code></pre>

<p>  end.</p>

<p>%% any/2
any(_P, []) ->
  false;
any(P, [H|T]) ->
  case P(H) of</p>

<pre><code>true -&gt; true;
false -&gt; any(P, T)
</code></pre>

<p>  end.</p>

<p>%% append/1
append(LL) ->
  [X || L &lt;- LL, X &lt;- L].</p>

<p>%% append/2
append(LA, LB) ->
  LA ++ LB.</p>

<p>%% delete/2
delete(E, L) ->
  [X || X &lt;- L, E /= X].</p>

<p>%% dropwhile/2
dropwhile(P, L) ->
  [X || X &lt;- L, not P(X)].</p>

<p>%% duplicate/2
duplicate(N, E) ->
  duplicate(N, E, []).
duplicate(0, _E, L) ->
  L;
duplicate(N, E, L) when N > 0 ->
  duplicate(N-1, E, [E|L]).</p>

<p>%% filter/2
filter(P, L) ->
  [X || X &lt;- L, P(X)].</p>

<p>%% reverse/1
reverse(L) ->
  reverse(L, []).
reverse([], L) ->
  L;
reverse([H|T], L) ->
  reverse(T, [H|L]).</p>

<p>%% min/1
min([H|T]) ->
  min(T, H).
min([], M) ->
  M;
min([H|T], M) ->
  if</p>

<pre><code>H &lt; M -&gt; min(T, H);
true -&gt; min(T, M)
</code></pre>

<p>  end.</p>

<p>%% zip/2
zip(LA, LB) ->
  reverse(zip(LA, LB, [])).
zip([], <em>LB, L) ->
  L;
zip(</em>LA, [], L) ->
  L;
zip([HA|TA], [HB|TB], L) ->
  zip(TA, TB, [{HA,HB}|L]).</p>

<p>%% zip/3
zip3(LA, LB, LC) ->
  reverse(zip3(LA, LB, LC, [])).
zip3([], <em>LB, </em>LC, L) ->
  L;
zip3(<em>LA, [], </em>LC, L) ->
  L;
zip3(<em>LA, </em>LB, [], L) ->
  L;
zip3([HA|TA], [HB|TB], [HC|TC], L) ->
  zip3(TA, TB, TC, [{HA,HB,HC}|L]).</p>

<p>%% zipwith/3
zipwith(P, LA, LB) ->
  [P(X,Y) || {X,Y} &lt;- zip(LA, LB)].</p>

<p>%% zipwith/4
zipwith3(P, LA, LB, LC) ->
  [P(X,Y,Z) || {X,Y,Z} &lt;- zip3(LA, LB, LC)].
{% endhighlight %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hello erlang, part 3]]></title>
    <link href="http://mccxj.github.com/blog/20120718_hello-erlang-3.html"/>
    <updated>2012-07-18T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/hello-erlang-3</id>
    <content type="html"><![CDATA[<h3>练习重点</h3>

<p>并发编程是erlang的重要话题，所以这次先来热身，熟悉一下erlang中进程的基本用法。</p>

<h3>练习1:进程环</h3>

<p>编写一个程序，它生成N个进程并相连形成一个环，一旦启动，这些进程会环绕发送M个消息。
然后当收到消息的时候正常终止。调用ring:start(M, N, Message)来启动环。</p>

<h3>思路及编程示例</h3>

<p>首先，为了形成环状，就是让最后一个进程能够给第一个进程发送消息，
调用spawn生成进程的时候，需要把第一个pid一直传递到最后一个。所以需要有个start的方法，
但需要多加个第一个进程id的参数，关注参数N=1作为临界点。</p>

<p>还有，需要等待消息，然后给下一个进程发送消息，之后继续等待消息，直到M=0。
所以需要一个等待消息的方法，同时需要关注参数M=0作为临界点。</p>

<p>最后，整个环，所有的进程一开始都在等待，需要有个消息来启动环，
可以在第一个进程启动下一个进程之前，往自身邮箱里边发送一条消息，
这样第一个进程进入等待消息的时候，就能接收到消息，从而启动环。</p>

<p>我的代码示例如下：
{% highlight erlang %}
-module(ring).</p>

<p>%% Exported Functions
-export([start/3]).
-export([start/4]).</p>

<p>%% API Functions
start(M, N, Message) ->
  self() ! {self(), start},
  start(M, N, Message, self()).</p>

<p>start(M, 1, Message, Rid) ->
  waitmessage(M, 1, Message, Rid);</p>

<p>start(M, N, Message, Rid) ->
  Pid = spawn(ring, start, [M, N-1, Message, Rid]),
  waitmessage(M, N, Message, Pid).</p>

<p>waitmessage(0, <em>N, </em>Message, _Pid) ->
  receive</p>

<pre><code>{Pd, Msg} -&gt;
  io:format("pid ~p receive message ~p from ~p~n", [self(), Msg, Pd])
  ok
</code></pre>

<p>  end;</p>

<p>waitmessage(M, N, Message, Pid) ->
  receive</p>

<pre><code>{Pd, Msg} -&gt;
  io:format("pid ~p receive message ~p from ~p~n", [self(), Msg, Pd]),
  Pid ! {self(), Message},
  waitmessage(M-1, N, Message, Pid)
</code></pre>

<p>  end.
{% endhighlight %}</p>

<p>通过简单的测试，如果去掉io:format的话，效率会提高不少。IO操作消耗的时间还是不可小视呀。
另外，测试大数量进程的时候，内存也用得比较厉害，毕竟这个练习更像是一个同步操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hello erlang, part 2]]></title>
    <link href="http://mccxj.github.com/blog/20120715_hello-erlang-2.html"/>
    <updated>2012-07-15T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/hello-erlang-2</id>
    <content type="html"><![CDATA[<h3>练习重点</h3>

<ol>
<li>依然是熟悉erlang匹配模式的编程方式，对于用习惯了判断，循环操作的人来说，这个变化很大</li>
<li>熟悉erlang列表操作</li>
<li>为后面学习高阶函数fun，还有更多高级数据类型打好基础</li>
</ol>


<h3>练习1:压缩有序列表</h3>

<p>类似搜索里边的倒排索引，需要对词对应的文档列表进行存放。
在这里，我们将一个有序列表转换成另外一种形式，如
{% highlight erlang %}
%% 原始形式
[1,1,2,4,5,6,6,98,100,101,102,102].
%% 最终形式
[{1,2},{4,6},{98,98},{100,102}].
{% endhighlight %}</p>

<h3>示例代码</h3>

<p>{% highlight erlang %}
multi(L) -> lists:reverse(multi_local(L, [])).
multi_local([], R) -> R;
multi_local([H|L], R) -></p>

<pre><code>{LL, E} = multi_r(L, H),
multi_local(LL, [{H, E}|R]).
</code></pre>

<p>%% 获取L里边里边和H同属一组的最后一个数,同时返回剩余的列表
%% 如果L以H开头，表示出现重复数
%% 如果L以H+1开头，表示出现序列数
multi_r(L, H) -></p>

<pre><code>N = H + 1,
case L of
    [H|LL] -&gt; multi_r(LL, H);
    [N|LL] -&gt; multi_r(LL, N);
    [] -&gt; {[], H};
    _ -&gt; {L, H}
end.
</code></pre>

<p>{% endhighlight %}</p>

<h3>效率问题</h3>

<p>这里和上次不一样的是，这里没有使用lists:append方法，而是在最后使用了reverse.</p>

<p>{% highlight erlang %}
<a href="20120712_horse-riding-chessboard.html">1</a> ++ [2, 3].
lists:append(<a href="20120712_horse-riding-chessboard.html">1</a>, [2, 3]).
lists:reverse([3|[2, 1]]).
{% endhighlight %}
上面三种方式得到的结果是一样的。前面两种，每增加一个元素，都会遍历左边的列表，所以在递归里边处理的话，
效率并不好。把元素添加到表头，在递归完成后进行反转，效果就会好些。</p>

<h3>练习2:马踏棋盘</h3>

<p>作为一个阶段的学习总结，对<a href="20120712_horse-riding-chessboard.html">马踏棋盘的算法思考</a>用erlang实现。</p>

<p>代码比较悲剧，我选择了array，用了一些fun函数，从这么个例子就可以看出，自己还没掌握好erlang惯用法。
感觉数据结构没有选好，并且用了命令语言的一些编程思路，有些东西或许可以用列表解析来弄，
等再掌握多一些东西，再回头来体会一把!
{% highlight erlang %}
-module(horse).</p>

<p>%% Exported Functions
-export([walkboard/0]).</p>

<p>%% API Functions
walkboard() ->
  %% lists:foreach(fun(I) -> lists:foreach(fun(J) -> walkboard({I, J}) end, lists:seq(0,7)) end, lists:seq(0,7)).
  walkboard({2,3}).</p>

<p>walkboard({I,J}) ->
  {ARR, PATH, POSS} = init(),
  catch walk(0, setvalue({I, J}, 1, ARR), array:set(0, {I,J}, PATH), POSS).</p>

<p>walk(63, <em>, PATH, </em>) -> throw(PATH);
walk(MARK, ARR, PATH, POSS) ->
  {IP, JP} = array:get(MARK, PATH),
  WC = fun({I,J,_}) -></p>

<pre><code>     walk(MARK+1, setvalue({I+IP,J+JP}, 1, ARR), array:set(MARK+1, {I+IP,J+JP}, PATH), POSS)
   end,
</code></pre>

<p>  lists:foreach(WC, filter(MARK, PATH, POSS, ARR)).</p>

<p>%%
%% Local Functions
%%
init() ->
  ARR = array:new(8, {default,array:new(8, {default,0})}),
  PATH = array:new(64),
  POSS = [{-2, 1}, {2, 1}, {1, 2}, {-1, 2}, {2, -1}, {-2, -1}, {-1, -2}, {1, -2}],
  {ARR, PATH, POSS}.</p>

<p>filter(MARK, PATH, POSS, ARR) ->
  {I, J} = array:get(MARK, PATH),
  Fun1 = fun({IP, JP}) -></p>

<pre><code>       {IXP, JXP} = {I+IP, J+JP},
       case valid({IXP, JXP}, ARR) of
         false -&gt; {IP, JP, -1};
         true -&gt; 
         %% 计算空点数
         CAL = fun({IP2, JP2}, Sum) -&gt; 
                 case valid({IXP+IP2, JXP+JP2}, ARR) of
                   true -&gt; 1 + Sum;
                   false -&gt; Sum
                 end
               end,
               {IP, JP, lists:foldl(CAL, 0, POSS)}
       end
     end,
</code></pre>

<p>  %% 最后进行排序
  T = lists:map(Fun1, POSS),
  S = lists:filter(fun({<em>, </em>, Z}) -> Z == 0 end, T),
  LEN = length(S),
  if</p>

<pre><code>LEN &gt; 1 -&gt; [];
LEN &gt; 0 -&gt; S;
true -&gt; SS = lists:filter(fun({_, _, Z}) -&gt; Z &gt;= 0 end, T),
    lists:sort(fun({_, _, Z1}, {_, _, Z2}) -&gt; Z1 &lt; Z2 end, SS)
</code></pre>

<p>  end.</p>

<p>valid({I,J}, ARR) ->
  I >= 0 andalso I<8 andalso J>=0 andalso J&lt;8 andalso getvalue({I,J}, ARR) == 0.</p>

<p>getvalue({I,J}, ARR) ->
  array:get(J, array:get(I, ARR)).</p>

<p>setvalue({I,J}, VAL, ARR) ->
  array:set(I, array:set(J, VAL, array:get(I, ARR)), ARR).
{% endhighlight %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hello erlang, part 1]]></title>
    <link href="http://mccxj.github.com/blog/20120714_hello-erlang-1.html"/>
    <updated>2012-07-14T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/hello-erlang-1</id>
    <content type="html"><![CDATA[<h3>练习重点</h3>

<ol>
<li>erlang是单赋值的，就好像都经过java里边的final修饰过</li>
<li>erlang没有内置的循环结构，这个和大多数语言是不一样的</li>
<li>erlang是函数式语言，需要理解模式匹配编程方式</li>
<li>erlang经常会遇到递归, 并且支持尾递归函数调用</li>
</ol>


<h3>练习1:数据库demo</h3>

<p>作为学习erlang里边的模式匹配，熟悉语法。
编写一个数据库模块db.erl，它能够存储、检索、删除元素。我们需要实现的接口有:
{% highlight erlang %}
db:new()                   %% Db.
db:destroy(Db)             %% ok.
db:write(Key, Element, Db) %% NewDb.
db:delete(Key, Db)         %% NewDb.
db:read(Key, Db)           %% {ok, Element} | {error, instance}.
db:match(Element, Db)      %% [Key1, ..., KeyN].
{% endhighlight %}</p>

<h3>实现代码</h3>

<p>{% highlight erlang %}
-module(db).</p>

<p>%% Exported Functions
-export([new/0, write/3, read/2, match/2, delete/2, destroy/1]).</p>

<p>%% API Functions
new() -> [].
destroy(_) -> ok.
write(Key, Element, DB) -> [{Key,Element}|DB].
delete(Key, DB) -> delete_local(Key, DB, []).
read(Key, DB) -></p>

<pre><code>case DB of
    [{Key, Element}|_] -&gt; {oKey, Element};
    [_|ODB] -&gt; read(Key, ODB);
    _ -&gt; {error, instance}
end.
</code></pre>

<p>match(Element, DB) -> match_local(Element, DB, []).</p>

<p>%% Local Functions
match_local(Element, DB, LIST) -></p>

<pre><code>case DB of
    [{Key, Element}|ODB] -&gt; match_local(Element, ODB, [Key|LIST]);
    [_|ODB] -&gt; match_local(Element, ODB, LIST);
    _ -&gt; LIST
end.
</code></pre>

<p>delete_local(Key, DB, NDB) -></p>

<pre><code>case DB of
    [{Key, _}|ODB] -&gt; delete_local(Key, ODB, NDB);
    [H|ODB] -&gt; delete_local(Key, ODB, [H|NDB]);
    _ -&gt; NDB
end.
</code></pre>

<p>{% endhighlight %}</p>

<p>当然，case语句同样可以用如下代码替代：其中第三行的Key因为没有使用就换成<em>,
不然会提示警告variable 'Key' is unused。
{% highlight erlang %}
delete_local(Key, [{key, </em>}|ODB], NDB) -> delete_local(Key, ODB, NDB);
delete_local(Key, [H|ODB], NDB) -> delete_local(Key, ODB, [H|NDB]);
delete_local(<em>, </em>, NDB) -> NDB;
{% endhighlight %}</p>

<h3>练习2:排序算法</h3>

<p>下面练习一下快速排序和归并排序，再熟悉一下模式匹配和递归的写法。
{% highlight erlang %}
-module(sort).
-export([quicksort/1, mergesort/1]).</p>

<p>%% 快速排序
quicksort([H|Tail]) -></p>

<pre><code>lists:append([quicksort(lists:filter(fun(X) -&gt; X &lt; H end, Tail)), 
              [H], 
              quicksort(lists:filter(fun(X) -&gt; X &gt;= H end, Tail))]);
</code></pre>

<p>quicksort(L) -> L.</p>

<p>%% 归并排序
mergesort(A) -></p>

<pre><code>case length(A) of
    0 -&gt; [];
    1 -&gt; A;
    LEN -&gt; M = length(A) div 2,
           merge(mergesort(lists:sublist(A, 1, M)), 
                 mergesort(lists:sublist(A, M + 1, LEN - M)), [])
end.
</code></pre>

<p>merge(A, [], L) -> lists:append([L, A]);
merge([], B, L) -> lists:append([L, B]);
merge([HA|TA], [HB|TB], L) -></p>

<pre><code>if
    HA &gt; HB -&gt; merge([HA|TA], TB, lists:append([L, [HB]]));
    true -&gt; merge(TA, [HB|TB], lists:append([L, [HA]]))
end.
</code></pre>

<p>{% endhighlight %}</p>
]]></content>
  </entry>
  
</feed>
