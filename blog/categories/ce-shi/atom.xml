<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 测试 | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/ce-shi/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2013-03-10T22:33:16+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hello erlang, part 4]]></title>
    <link href="http://mccxj.github.com/blog/20120721_hello-erlang-4.html"/>
    <updated>2012-07-21T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/hello-erlang-4</id>
    <content type="html"><![CDATA[<h3>练习重点</h3>

<p>列表解析和高阶函数是erlang的基本用法之一，熟练掌握还是很有必要的。
作为一个阶段的学习总结，按照书上的一个练习题，尝试实现列表模块中的一些方法。</p>

<h3>后续学习计划</h3>

<p>再找时间总结一下位匹配用法，然后就开始客户端服务器编程模型，
网络和分布式方面的内容。</p>

<p>相关内容虽然都看过一下，但是没有敲过代码，感觉心里没底。还是那个硬道理：纸上得来终觉浅呀。</p>

<h3>简单的测试用例</h3>

<p>作为另外一个章节的内容，单元测试。我顺便实践一下erlang的单元测试框架eunit，
里边使用了宏来作为assert语句(使用eclipse插件可以有很好的提示)，
总的来说，xunit的基本风格都差不多，注意import eunit的包，方法名采用_test结束。
执行的时候调用模块的test方法就可以了。我简单写了一些测试用例:</p>

<p>{% highlight erlang %}
-module(myliststest).
-include_lib("eunit/include/eunit.hrl").
-import_all(mylists).</p>

<p>%% EUnit TestCase</p>

<p>%% all/2
all_empty_test() ->
  ?assert(mylists:all(fun(E) -> E > 10 end, [])).
all_test() ->
  ?assertNot(mylists:all(fun(E) -> E > 10 end, [11,12,10])).</p>

<p>%% any/2
any_empty_test() ->
  ?assertNot(mylists:any(fun(E) -> E > 10 end, [])).
any_test() ->
  ?assert(mylists:any(fun(E) -> E > 10 end, [11,12,10])).</p>

<p>%% append/1
append_1_test() ->
  ?assertEqual([1,2,3,a,b,4,5,6], mylists:append([[1, 2, 3], [a, b], [4, 5, 6]])).</p>

<p>%% append/2
append_2_test() ->
  ?assertEqual("abcdef", mylists:append("abc", "def")).</p>

<p>%% delete/2
delete_test() ->
  ?assertEqual([1,2,4], mylists:delete(3, [1,2,3,4])).</p>

<p>%% dropwhile/2
dropwhile_test() ->
  ?assertEqual([1,2], mylists:dropwhile(fun(E) -> E >= 3 end, [1,2,3,4])).</p>

<p>%% duplicate/2
duplicate_test() ->
  ?assertEqual([x, x], mylists:duplicate(2, x)).</p>

<p>%% filter/2
filter_test() ->
  ?assertEqual([3,4], mylists:filter(fun(E) -> E >= 3 end, [1,2,3,4])).</p>

<p>%% reverse/1
reverse_test() ->
  ?assertEqual([4,3,2,1], mylists:reverse([1,2,3,4])).</p>

<p>%% min/1
min_test() ->
  ?assertEqual(2, mylists:min([3,4,2,5])).</p>

<p>%% zip/2
zip_2_test() ->
  ?assertEqual([{1,3},{2,4}], mylists:zip([1,2], [3,4,5])).</p>

<p>%% zip/3
zip_3_test() ->
  ?assertEqual([{1,3,5},{2,4,7}], mylists:zip3([1,2], [3,4,5], [5,7])).</p>

<p>%% zipwith/3
zipwith_test() ->
  ?assertEqual([5,7,9], mylists:zipwith(fun(X, Y) -> X+Y end, [1,2,3], [4,5,6])).</p>

<p>%% zipwith/4
zipwith3_test() ->
  ?assertEqual([[a,x,1],[b,y,2],[c,z,3]], mylists:zipwith3(fun(X, Y, Z) -> [X,Y,Z] end, [a,b,c], [x,y,z], [1,2,3])).
{% endhighlight %}</p>

<h3>示例代码</h3>

<p>根据上面的测试用例，我写了实现代码，如下所示。注意的时候，我偷懒使用了export_all,
但是min/2好像默认有一个已经被引入了，所以需要去除这个模块。就export_all本身来说，
也不是推荐方式，还是应该严格区分public api和local api。
{% highlight erlang %}
-module(mylists).
-compile(export_all).
-compile({no_auto_import,[min/2]}).</p>

<p>%% all/2
all(_P, []) ->
  true;
all(P, [H|T]) ->
  case P(H) of</p>

<pre><code>true -&gt; all(P, T);
false -&gt; false
</code></pre>

<p>  end.</p>

<p>%% any/2
any(_P, []) ->
  false;
any(P, [H|T]) ->
  case P(H) of</p>

<pre><code>true -&gt; true;
false -&gt; any(P, T)
</code></pre>

<p>  end.</p>

<p>%% append/1
append(LL) ->
  [X || L &lt;- LL, X &lt;- L].</p>

<p>%% append/2
append(LA, LB) ->
  LA ++ LB.</p>

<p>%% delete/2
delete(E, L) ->
  [X || X &lt;- L, E /= X].</p>

<p>%% dropwhile/2
dropwhile(P, L) ->
  [X || X &lt;- L, not P(X)].</p>

<p>%% duplicate/2
duplicate(N, E) ->
  duplicate(N, E, []).
duplicate(0, _E, L) ->
  L;
duplicate(N, E, L) when N > 0 ->
  duplicate(N-1, E, [E|L]).</p>

<p>%% filter/2
filter(P, L) ->
  [X || X &lt;- L, P(X)].</p>

<p>%% reverse/1
reverse(L) ->
  reverse(L, []).
reverse([], L) ->
  L;
reverse([H|T], L) ->
  reverse(T, [H|L]).</p>

<p>%% min/1
min([H|T]) ->
  min(T, H).
min([], M) ->
  M;
min([H|T], M) ->
  if</p>

<pre><code>H &lt; M -&gt; min(T, H);
true -&gt; min(T, M)
</code></pre>

<p>  end.</p>

<p>%% zip/2
zip(LA, LB) ->
  reverse(zip(LA, LB, [])).
zip([], <em>LB, L) ->
  L;
zip(</em>LA, [], L) ->
  L;
zip([HA|TA], [HB|TB], L) ->
  zip(TA, TB, [{HA,HB}|L]).</p>

<p>%% zip/3
zip3(LA, LB, LC) ->
  reverse(zip3(LA, LB, LC, [])).
zip3([], <em>LB, </em>LC, L) ->
  L;
zip3(<em>LA, [], </em>LC, L) ->
  L;
zip3(<em>LA, </em>LB, [], L) ->
  L;
zip3([HA|TA], [HB|TB], [HC|TC], L) ->
  zip3(TA, TB, TC, [{HA,HB,HC}|L]).</p>

<p>%% zipwith/3
zipwith(P, LA, LB) ->
  [P(X,Y) || {X,Y} &lt;- zip(LA, LB)].</p>

<p>%% zipwith/4
zipwith3(P, LA, LB, LC) ->
  [P(X,Y,Z) || {X,Y,Z} &lt;- zip3(LA, LB, LC)].
{% endhighlight %}</p>
]]></content>
  </entry>
  
</feed>
