<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 实践 | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/shi-jian/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2013-03-10T22:33:16+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Node.js Best practices]]></title>
    <link href="http://mccxj.github.com/blog/20130102_nodejs-best-practices.html"/>
    <updated>2013-01-02T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/nodejs-best-practices</id>
    <content type="html"><![CDATA[<p><strong>完整的ppt来源于<a href="http://www.slideshare.net/the_undefined/nodejs-best-practices-10428790">Node.js Best practices</a>,作者<a href="http://www.slideshare.net/the_undefined">Felix Geisendörfer</a>,需翻越</strong></p>

<h3>Callbacks</h3>

<p>下面是关于解析json文件的示例代码:
{% highlight javascript %}
var fs = require('fs);
function readJSON(path, cb){
  fs.readFile(path, 'utf8', function(err, data){</p>

<pre><code>cb(JSON.parse(data));
</code></pre>

<p>  }
}
{% endhighlight %}</p>

<p>显然，上面的代码没有处理异常情况，因此再加个异常处理逻辑上去:
{% highlight javascript %}
var fs = require('fs);
function readJSON(path, cb){
  fs.readFile(path, 'utf8', function(err, data){</p>

<pre><code>if(err) return cb(err);
cb(JSON.parse(data));
</code></pre>

<p>  }
}
{% endhighlight %}</p>

<p>还没有结束，我们还没考虑到文件内容不是json这种情况，会导致parse出现异常，因此再处理一下：
{% highlight javascript %}
var fs = require('fs);
function readJSON(path, cb){
  fs.readFile(path, 'utf8', function(err, data){</p>

<pre><code>if(err) return cb(err);
try{
  cb(JSON.parse(data));
}catch(err){
  cb(err);
}
</code></pre>

<p>  }
}
{% endhighlight %}</p>

<p>对于cb来说，仍然无法区分正常结果和异常内容，这个问题通常可以通过增加一个err参数来处理，如:
{% highlight javascript %}
var fs = require('fs);
function readJSON(path, cb){
  fs.readFile(path, 'utf8', function(err, data){</p>

<pre><code>if(err) return cb(err);
try{
  var json = JSON.parse(data);
}catch(err){
  return cb(err);
}
cb(null, json);
</code></pre>

<p>  }
}
{% endhighlight %}</p>

<p><strong>这个示例告诉我们，对于callback，需要时刻准备应付正常结果和异常情况的处理。</strong></p>

<p>再来看看另外一个常见错误:
{% highlight javascript %}
function readJSONFiles(files, cb){
  var results = {};
  var remaining = files.length;</p>

<p>  files.forEach(function(file){</p>

<pre><code>readJSON(file, function(err, json){
  if(err) return cb(err);

  results[file] = json;
  if(!--remaining) cb(null, results);
}
</code></pre>

<p>  });
}
{% endhighlight %}</p>

<p>这里隐含了一个常见的场景:<strong>批量处理时，任意一个失败，及时退出</strong>。有时候可以用标识符，这里采用另外一种手法：<strong>重置回调方法</strong>。
{% highlight javascript %}
function readJSONFiles(files, cb){
  var results = {};
  var remaining = files.length;</p>

<p>  files.forEach(function(file){</p>

<pre><code>readJSON(file, function(err, json){
  if(err){
    cb(err);
    cb = function(){};
    return;
  }

  results[file] = json;
  if(!--remaining) cb(null, results);
}
</code></pre>

<p>  });
}
{% endhighlight %}</p>

<h3>Nested Callbacks</h3>

<p>先看看一个恐怖的例子:
{% highlight javascript %}
db.query('SELECT A ...', function(){
  db.query('SELECT B ...', function(){</p>

<pre><code>db.query('SELECT C ...', function(){
  db.query('SELECT D ...', function(){
  });
});
</code></pre>

<p>  });
});
{% endhighlight %}</p>

<p>活生生就是一个怪物:)，多层嵌套的回调不是很好的风格，我们需要一些流程控制的东西来辅助，例如Control Flow Libs:
{% highlight javascript %}
var async = require('async');</p>

<p>async.series({
  queryA: function(next){</p>

<pre><code>db.query('SELECT A ...', next);
</code></pre>

<p>  },
  queryB: function(next){</p>

<pre><code>db.query('SELECT B ...', next);
</code></pre>

<p>  },
  queryA: function(next){</p>

<pre><code>db.query('SELECT C ...', next);
</code></pre>

<p>  }
  // ...
}, function(err, results){
  //...
});
{% endhighlight %}</p>

<p>像上面的代码，最明显的地方就是异常处理被完全隔离出来。<strong>如果要把代码分布到很多小方法里边的话，Node.js的确不是很容易做到</strong>。</p>

<h3>Exceptions</h3>

<p>通常throw new Error(msg)可以让你的程序进行异常退出，并在控制台上输入错误信息和堆栈信息。</p>

<p>但有时候我们要考虑的是，<strong>一些未知的bug</strong>，例如下面一个有bug的示例:
{% highlight javascript %}
function MyClass(){}</p>

<p>MyClass.prototype.myMethod = function(){
  setTimeout(function(){</p>

<pre><code>this.myOtherMethod();
</code></pre>

<p>  }, 10);
}</p>

<p>MyClass.prototype.myOtherMethod = function(){};</p>

<p>(new MyClass).myMethod();
{% endhighlight %}</p>

<p>我们可以采用Global Catch的方式:
{% highlight javascript %}
process.on('uncaughtException', function(err){
  console.err('uncaught exception: ' + err.stack);
});
{% endhighlight %}</p>

<p>更好的处理方式是:<strong>进程挂了，认栽了，到更高层面上去处理</strong>。
{% highlight javascript %}
process.on('uncaughtException', function(err){
  // You could use node-airbake for this
  sendErrorToLog(function(){</p>

<pre><code>// Once the error was logged, kill the process
console.err(err.stack);
process.exit(1);
</code></pre>

<p>  }
});
{% endhighlight %}</p>

<h3>Deployment</h3>

<p>比较初级的方式是采用node直接运行或在后台运行。老手可能会采用一个脚本来搞:
{% highlight bash %}</p>

<h1>! /bin/bash</h1>

<p>while :
do
  node server.js
  echo "Server crashed!"
  sleep 1
done
{% endhighlight %}</p>

<p>专家级采用的方式可能是(借助成熟的集成工具):
{% highlight bash %}</p>

<h1>!upstart</h1>

<p>description "myapp"
author "felix"</p>

<p>start on(local-filesystems and net-device-up IFACE=eth0)
stop on shutdown</p>

<p>respawn # restart when job dies
respawn limit 5 60 # give up restart after 5 respawns in 60 seconds</p>

<p>script
  exec sudo -u www-data /path/to/server.js >> /var/log/myapp.log 2>&amp;1
end script
{% endhighlight %}</p>

<p>当然，还有些创新风格的(基于托管平台的):
{% highlight bash %}
$git push joyent master
$git push nodejitsu master
$git push heroku master
{% endhighlight %}</p>

<p><strong>没有托管平台的话，借助成熟的工具应该是最好的选择，性价比高。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[maven学习要点(旧)]]></title>
    <link href="http://mccxj.github.com/blog/20121130_maven-quickstart.html"/>
    <updated>2012-11-30T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/maven-quickstart</id>
    <content type="html"><![CDATA[<p>我感觉maven这东西比ant容易上手(ant每个项目规则都不一样),看那个100页的迷你书+例子(推荐basecrm或spring3.0)基本就ok了~~
哎，本来想写的很多，发现写出来的却很少。多多包涵!</p>

<ul>
<li>maven是一个项目管理工具，跟ant相比亮点在于它遵守了COC规则，只要遵守就好处多多</li>
<li>maven可以分为三部分:maven本身(提供基本功能),仓库(提供jar),maven插件(提供更多的集成功能)</li>
<li>maven的配置文件是settings.xml,maven项目的配置文件是pom.xml</li>
<li><p>settings.xml主要是配置仓库镜像,本地仓库,网络访问设置等信息,常用配置:
{% highlight xml %}
<localRepository>D:/repository</localRepository> --本地仓库
 <proxy>  --网络代理
   <id>optional</id>
   <active>true</active>
   <protocol>http</protocol>
   <username>proxyuser</username>
   <password>proxypass</password>
   <host>proxy.host.net</host>
   <port>80</port>
   <nonProxyHosts>local.net|some.host.com</nonProxyHosts>
 </proxy>
<mirror>  --仓库镜像
  <id>nexus</id>
  <mirrorOf>*</mirrorOf>
  <name>Mirror for maven central.</name>
  <url>http://10.137.27.223:8080/nexus/content/groups/public</url>
</mirror>
{% endhighlight %}</p></li>
<li><p>pom.xml主要分为三部分:项目本身的信息,使用的插件,依赖的jar</p></li>
<li><p>项目本身的信息,用于唯一标识(groupid-artifactId-version, 通常是这3部分)，例如
{% highlight xml %}
<modelVersion>4.0.0</modelVersion> --maven3.x都是使用4.0.0
<groupId>com.huawei.boss</groupId>
<artifactId>boss-common</artifactId>
<version>0.0.1-SNAPSHOT</version>
<packaging>jar</packaging>
{% endhighlight %}
类似这个，默认就会被打包成boss-common-0.0.1-SNAPSHOT.jar。同样，项目的依赖库也是通过这种坐标在仓库中寻找的。</p></li>
<li><p>artifactId通常推荐使用项目名当前缀,当项目是打包成war的时候,通常需要制定发布后的命名:
{% highlight xml %}
<build>
 <finalName>bossbase</finalName>
</build>
{% endhighlight %}</p></li>
<li>可以通过properties定义一些常量,并通过${spring.version}之类来引用
{% highlight xml %}
<properties>

<pre><code> &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
 &lt;spring.version&gt;2.5.6&lt;/spring.version&gt;
</code></pre>

<p></properties>
{% endhighlight %}</p></li>
<li><p>jar包依赖常用的有如下配置(仅举例说明):
{% highlight xml %}
<dependencies>
   <dependency></p>

<pre><code>     &lt;groupId&gt;org.springframework&lt;/groupId&gt;
         &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
       &lt;version&gt;${spring.version}&lt;/version&gt;  --常量引用,在引用同个项目多个模块的时候相当有效
     &lt;type&gt;jar&lt;/type&gt;  --默认就是jar
       &lt;scope&gt;compile&lt;/scope&gt;  --默认是compile,表示对编译,测试,运行都有效
 &lt;/dependency&gt;
</code></pre>

  <dependency>

<pre><code>    &lt;groupId&gt;geronimo-spec&lt;/groupId&gt;
      &lt;artifactId&gt;geronimo-spec-jta&lt;/artifactId&gt; --这个是为了不依赖sun的专用东东
     &lt;version&gt;1.0.1B-rc4&lt;/version&gt;
          &lt;type&gt;pom&lt;/type&gt;
    &lt;scope&gt;provided&lt;/scope&gt;  --在运行的时候不依赖，我们常见的时候j2ee规范之类的api,如servlet-api
</code></pre>

</dependency>

<pre><code> &lt;dependency&gt;
       &lt;groupId&gt;junit&lt;/groupId&gt;
         &lt;artifactId&gt;junit&lt;/artifactId&gt;
     &lt;version&gt;4.8.2&lt;/version&gt;
       &lt;type&gt;jar&lt;/type&gt;
         &lt;scope&gt;test&lt;/scope&gt;  --只在测试的时候生效,另外还有个ruuntime的scope,用于运行时依赖(如jdbc驱动等)
&lt;/dependency&gt;
</code></pre>

 <dependency>
   <groupId>org.hibernate</groupId>
   <artifactId>hibernate</artifactId>
   <version>3.2.5.ga</version>
   <exclusions>  --这里是排除依赖，因为jta官方版是在maven仓库中找不到的

<pre><code> &lt;exclusion&gt;
   &lt;groupId&gt;javax.transaction&lt;/groupId&gt;
   &lt;artifactId&gt;jta&lt;/artifactId&gt;
 &lt;/exclusion&gt;
</code></pre>

<p>   </exclusions>
 </dependency>
</dependencies>
{% endhighlight %}</p></li>
<li><p>当项目是分模块进行的时候,通常会考虑使用modules,如:
{% highlight xml %}
 <modules></p>

<pre><code> &lt;module&gt;basecrm-parent&lt;/module&gt;
 &lt;module&gt;common&lt;/module&gt;
 &lt;module&gt;systemmgr&lt;/module&gt;
 &lt;module&gt;prodmgr&lt;/module&gt;
</code></pre>

<p> </modules>
{% endhighlight %}
这个时候至少会有两级pom.xml,这样像properties,dependency等都是可以继承的(可参考basecrm项目或者spring3.x)</p></li>
<li><p>plugin资源非常多，简单举几个常用插件(配置请上网找)<br/>
maven-compiler-plugin 主要是配置编译方面的选项(例如使用什么版本的jdk)<br/>
maven-surefire-plugin 跟测试有关的,例如配置测试失败是否继续,是否跳过测试等<br/>
build-helper-maven-plugin 用于配置项目的目录结构,例如配置多个源代码目录等<br/>
maven-shade-plugin 我只知道可以用来给打包加点料~~<br/>
tomcat-maven-plugin 顾名思义,用于集成tomcat<br/>
maven-jetty-plugin 顾名思义,用于集成jetty</p></li>
<li><p>others <br/>
maven仓库代理推荐nexus(网内已经有个现成的:http://10.137.27.223:8080/nexus)<br/>
eclipse中的maven插件推荐m2eclipse(update-site: http://m2eclipse.sonatype.org/sites/m2e)<br/>
maven实战迷你书(http://www.infoq.com/cn/minibooks/maven-in-action)</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jstl学习经验(旧)]]></title>
    <link href="http://mccxj.github.com/blog/20121130_jstl.html"/>
    <updated>2012-11-30T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/jstl</id>
    <content type="html"><![CDATA[<p>为了在公司里边推广jstl，而总结的一些jstl使用技巧:</p>

<h4>jstl可以很方便的处理NullPointException,访问越界等常见问题</h4>

<p>{% highlight jsp %}
&lt;c:set var=”SPExtraInfoList” value=”${queryresult[3]}”/>
&lt;c:out value=”${queryresult[3]}”/>
{% endhighlight %}
这2个表达式不会因为没有第四个元素而报错</p>

<h4>这2个表达式一般情况下表现是一样的，只是用c:out可以带上default的参数来处理NullPointException</h4>

<p>{% highlight jsp %}
<td>&lt;c:out value=”${spservice.m_SpID}”/></td>
<td>${spservice.m_SpID}</td>
{% endhighlight %}</p>

<h4>即使担心其他Exception,也可以通过c:catch来做防御</h4>

<p>{% highlight jsp %}
&lt;c:catch>&lt;c:out value=”${values[9]/1000.00}”/>&lt;/c:catch>
{% endhighlight %}</p>

<h4>fn:length的使用</h4>

<p>用来判断集合类型或String的长度，不过只是用来判断obj是否为空的话，用le语言${empty obj}更方便(同样支持多种类型)</p>

<h4>关于fn:split</h4>

<p>用这个方法切割会丢失空字符串,原因是这个标签使用StringTokenizer来处理而不是split方法。
{% highlight jsp %}
&lt;% String[] values = ((CEntityString)pageContext.getAttribute(“service”)).EntityString.split(“,”);
   pageContext.setAttribute(“values”, values);  %>
{% endhighlight %}
这是比较丑的例子，对格式依赖比较严重，所以最好就使用比较清晰的结构</p>

<h4>关于if-else和三元表达式</h4>

<p>jstl做判断分支是比较麻烦的，只提供了c:otherwise的方式，只好将就点先用着吧。如
{% highlight jsp %}
&lt;c:choose>&lt;c:when test=”${’1′ eq spextrainfo[0]}”>是&lt;/c:when>&lt;c:otherwise>否&lt; /c:otherwise>&lt;/c:choose>
{% endhighlight %}</p>

<h4>jstl改变操作</h4>

<p>jstl里边要做访问操作是比较方便的，不过涉及改变就挺麻烦的，如对某个字符串加个头，然后在Map里边检索，这样就不能在一个表达式里边写完，需要先c:set一下,如
{% highlight jsp %}
&lt;c:set var=”bzType” value=”BizType${spservice.m_SpBizType}”/>
&lt;c:out value=”${BizTypeMap[bzType]}”/>
{% endhighlight %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ibatis进阶(旧)]]></title>
    <link href="http://mccxj.github.com/blog/20121130_ibatis-more-config.html"/>
    <updated>2012-11-30T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/ibatis-more-config</id>
    <content type="html"><![CDATA[<h2>Ibatis比较少人使用的配置语法</h2>

<p>简单来说，ibatis3虽然没有ognl,不过也支持基本的表达式（看起来有点像el表达式的样子) 上次有个问题，说到两个表单数据(两个javabean)，入同一个表，传参就应该不成问题了</p>

<h4>java代码1:</h4>

<p>{% highlight java %}
   Map map = new HashMap();
   ComplexBean bean = new ComplexBean();
   bean.setMap(new HashMap());
   bean.getMap().put("id", new Integer(1));
   map.put("bean", bean);
   Account account = new Account();
   account.setId(2);
   Account anotherAccount = new Account();
   anotherAccount.setId(3);
   map.put("accounts", new Account[] {account, anotherAccount});
   Integer id = (Integer) sqlMap.queryForObject("mapBeanMap", map);
{% endhighlight %}</p>

<h4>ibatis配置1:</h4>

<p>{% highlight xml %}
 <select id="mapBeanMap"
   parameterClass="map"
   resultClass="int" >
   select count(ACC_ID) from Account where ACC_ID in (#bean.map.id#,#accounts[0].id#,#accounts[1].id#)
 </select>
{% endhighlight %}</p>

<h4>java代码2:</h4>

<p>{% highlight java %}
   Map map = new HashMap();
   ComplexBean bean = new ComplexBean();
   bean.setMap(new HashMap());
   Account account = new Account();
   account.setId(2);
   Account anotherAccount = new Account();
   anotherAccount.setId(3);
   bean.getMap().put("accounts", new Account[] {account, anotherAccount});
   map.put("bean", bean);
{% endhighlight %}</p>

<h4>ibatis配置2:</h4>

<p>{% highlight xml %}
 <select id="mapBeanMap2"
   parameterClass="map"
   resultClass="int" >
   select count(ACC_ID) from Account where ACC_ID in
   <iterate close=")" open="(" conjunction="," property="bean.map.accounts"></p>

<pre><code> #bean.map.accounts[].id#
</code></pre>

<p>   </iterate>
 </select>
{% endhighlight %}</p>

<h2>ibatis与泛型</h2>

<p>当使用复杂配置并且参数带有泛型的时候，使用比较标签有可能导致如下错误:There is no READABLE property named ‘XXX’ in class ‘java.lang.Object’.这是因为进行比较的时候，ibatis是通过反射获取类型而不是先计算值的,这样泛型的时候会获取到Object类而不能得到真实的类型,自己简单打个补丁先:
{% highlight diff %}</p>

<h1>Index: src/com/ibatis/sqlmap/engine/mapping/sql/dynamic/elements/ConditionalTagHandler.java</h1>

<p>--- src/com/ibatis/sqlmap/engine/mapping/sql/dynamic/elements/ConditionalTagHandler.java (revision 1079874)
+++ src/com/ibatis/sqlmap/engine/mapping/sql/dynamic/elements/ConditionalTagHandler.java (working copy)
@@ -72,14 +72,13 @@</p>

<pre><code> if (prop != null) {
   value1 = PROBE.getObject(parameterObject, prop);
</code></pre>

<ul>
<li>   type = PROBE.getPropertyTypeForGetter(parameterObject, prop);
 } else {
   value1 = parameterObject;</li>
<li>   if (value1 != null) {</li>
<li><pre><code> type = parameterObject.getClass();
</code></pre></li>
<li>   } else {</li>
<li><pre><code> type = Object.class;
</code></pre></li>
<li>   }</li>
<li> }</li>
<li> if (value1 != null) {</li>
<li>  type = value1.getClass();</li>
<li> } else {</li>
<li>  type = Object.class;
 }
 if (comparePropertyName != null) {
   Object value2 = PROBE.getObject(parameterObject, comparePropertyName);
{% endhighlight %}</li>
</ul>


<h2>关于inlineParameterMap</h2>

<p>例如#name#(标准配置),#name:NUMBER#(以:分割),#myVar:javaType=int#都是有效的
其中以:分割的有两种方式，#name:jdbcTypeName#,#name:jdbcTypeName:nullvalue#(如果后面还有则会被加到nullvalue上去) 这是老配置方法，个人不推荐使用。
最后一种是新的配置方式,可以带上javaType,jdbcType,mode,nullValue,numericScale,handler等参数(这个文档有详细描述)</p>

<h2>jdbcType,javaType和TypeHandler</h2>

<p>首先要说明一点的是,配置里边的jdbcType和javaType两个配置参数是为了生成TypeHandler(如果没有指定的话);
查找typeHandler的内部结构是Map&lt;javaType, Map&lt;jdbcType, typeHandler&gt;&gt;,其中javaType是一个类,jdbcType是一个字符串;
所以jdbcType其实和数据库的字段类型没什么关系,只要能找到相应的TypeHandler即可(当然通常都会对应上);
typeHandler主要是做什么用的呢?无非就是使用jdbc api的时候选择setString/setInt还是getString/getObject之类</p>

<h2>只指定resultClass，没有resultMap</h2>

<p>如果没有指定resultMap，ibatis会根据parameterClass生成一个AutoResultMap对象;
对于AutoResultMap,里边的每个属性的映射对应的typeHandler是什么?</p>

<table markdown="1" class="table">
  <tr><td>resultClass</td><td>TypeHandler</td></tr>
  <tr><td>Map</td><td>ObjectTypeHandler</td></tr>
  <tr><td>原型类型</td><td>相应类对应的typeHandler(javaType=?,jdbcType=null)</td></tr>
  <tr><td>Bean</td><td>会对实例变量名称进行大写并和ResultSetMetaData信息进行对比,最后生成typeHandler(javaType=?,jdbcType=null)</td></tr>
</table>


<p>所以使用parameterClass是map的时候，某些字段的处理可能会有点问题,例如oracle的NUMBER类型会被转成BigDecimal类;</p>

<h2>只指定parameterClass，没有parameterMap</h2>

<p>如果没有指定parameterMap，就会根据配置的sql解析inlineParameterMap;
其中每个参数的TypeHandler如果没有指定，会根据参数的类型来寻找，例如#name,jdbcType=NUMBER# 会根据name计算后的类型来制定javaType
这个typeHandler的好处可以对jdbc api友好，例如对于int默认会采用IntegerTypeHandler，这样会调用PreparedStatement#setInt, 而不是统统setString或者setObject。
通常参数类型和jdbc类型不对应的时候，需要考虑设置typeHandler或者使用更强类型的Bean而不是统统使用map;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[findbugs使用有感(旧)]]></title>
    <link href="http://mccxj.github.com/blog/20121130_findbugs.html"/>
    <updated>2012-11-30T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/findbugs</id>
    <content type="html"><![CDATA[<p>最近抽出点时间来处理项目上庞大的findbugs问题,处理过程中总结了下面几类参见的毛病：</p>

<h3>关于IO流</h3>

<p>见过的有写response的outputStream,文件下载,数据导出。这些场景涉及流读取、写入和最后的关闭，是findbugs检查的重灾区.
解决办法是使用common-io库,常用的方法有IOUtils#copy,IOUtils#write,IOUtils#closeQuietly。</p>

<h3>关于无效变量操作</h3>

<p>包括变量使用后置null,没有被使用的变量，虽然这种findbugs问题很低级,不过在系统中仍然存在很多。
处理办法是
1. 变量使用后置null是没什么用的,JVM的GC比想象中智能多了；
2. 假如变量在稍后的处理过程一定会被赋值,则init是没有意义的。<br/>
遵循的原则是相关的变量和操作集中在一起，缩短变量的作用域(同时，这样也对JVM比较友好)</p>

<h3>关于对象的延时加载</h3>

<p>系统中有些类实现了延时加载的singleton模式，还有的Action类中的实例变量使用了延时加载的方式。
很不幸的是，singleton的延时加载实现几乎都是错的, Action类的实例变量延时加载也没什么意义。
要实现singleton，最简单的方式是预加载方式,如果想做延时加载,可以使用内部静态类的实现方式。</p>

<h3>关于执行效率</h3>

<p>包括string的修改操作,map的遍历操作。如果有string的大量修改操作，应该使用StringBuffer或者StringBuilder
(在jdk5以上，StringBuilder适用于大多数场合)。而对于map的遍历,应该使用entrySet而不是keySet,这些注意一下就ok了。
另外系统有很多DateFormater的东西，用了很多静态变量来提高效率，可惜jdk的日期库是非常烂的,DateFormater也不是线程安全的东西，应该避免使用静态变量。</p>

<h3>关于异常处理</h3>

<p>Exception is caught when Exception is not thrown 这个findbugs问题在系统出现非常多，也是最难处理的问题。从这个点
就可以看出系统实现非常混乱，本来属于不同抽象层次的代码都堆在一起了，没有层次之分。这个问题一般是需要修改到那段逻辑的时候才会去
解决，通过抽取方法/类的方式，把异常进行抽象化，最后借助框架层次上的异常统一处理逻辑就通常可以把Action上面的所有的try-catch干掉。</p>

<h3>关于注释</h3>

<p>这其实不是findbugs问题。可以发现java代码里边很多注释是没什么用的，包括一些显而易见的注释,方法注释(通常只有方法描述是有点意义，其他都是抄模板的)
注释写不好，还不如不写，正确的做法是尽量写出自文档化的代码。</p>
]]></content>
  </entry>
  
</feed>
