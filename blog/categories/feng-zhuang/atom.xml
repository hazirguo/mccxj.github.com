<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 封装 | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/feng-zhuang/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2013-06-30T18:14:17+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[improve bitter code: 没有行为的封装]]></title>
    <link href="http://mccxj.github.com/blog/20120815_improve-bitter-code-9.html"/>
    <updated>2012-08-15T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/improve-bitter-code-9</id>
    <content type="html"><![CDATA[<p><strong>备注: 示例中的代码并不是真实代码的完全拷贝</strong></p>

<h3>常见的对象</h3>

<p>javabean这种java类是非常常见的，它有一些属性和相应的get/set方法。
我们还会看到pojo,vo这些概念，还有我们使用的一种特殊对象cbo，在外观上都是这种形式。</p>

<p>在项目的代码中，我们经常大量这种对象，它有私有变量，对每个私有变量都提供了get/set方法,除此之外，没有其他方法。
这种情况下，通常只需写好变量，然后用工具生成相应的访问器方法。</p>

<p>在最近修改一处代码的时候，就看到下面的逻辑，并且这段代码在多个文件出现过。
{% highlight java %}
PrepaidInput prepaid = ...// load from request</p>

<p>String start = prepaid.getStartTime();
String end = prepaid.getEndTime();</p>

<p>if(StringUtils.isNotEmpty(start)){</p>

<pre><code>String newstart = start.replaceAll("-", "");
if(newstart.length() &gt; 8){
    newstart = newstart.substring(0, 9);
    prepaid.setStartTime(newstart);
}
</code></pre>

<p>}</p>

<p>// 继续处理结束时间end
{% endhighlight %}</p>

<h3>封装还需要行为</h3>

<p>上面的代码是很常见的处理方式，对象只是传值的作用。给变量封装到方法里边，提供了get/set方法。
本质上来说，就像换了个马甲，和直接暴露数据差不多。类似的代码出现很多，先看下面简单点得例子：
{% highlight java %}
if("1".equals(subs.getStatus())){</p>

<pre><code>     //TODO
</code></pre>

<p>}
{% endhighlight %}
没有行为，顶多算是基于对象的编程。
从行为及职责考虑，这里暴露了状态值1，因为调用方必须理解这个值的作用。
封装，除了封装数据，还得封装出行为的样子来。如：
{% highlight java %}
if(subs.isActive()){</p>

<pre><code>     //TODO
</code></pre>

<p>}
{% endhighlight %}</p>

<p>对于最前面的代码，修改方式有很多，有一种方式就是在set里边, 组装对象的时候调用set方法顺便把格式给处理了。<br/>
没有规定说get.set都会对应一个私有变量，也没有规定get.set要成对出现，如果这是在内部使用的变量，为什么要暴露出来?<br/>
同样除了get/set也没有规定不能提供其他的方法。
{% highlight java %}
void setStartTime(String startTime){</p>

<pre><code>String newstart = startTime;
if(StringUtils.isNotEmpty(startTime)){
    String newstart = startTime.replaceAll("-", "");
    if(newstart.length() &gt; 8){
        newstart = newstart.substring(0, 8);
    }
}
this.startTime = newstart;
</code></pre>

<p>}
{% endhighlight %}</p>

<h3>现实情况</h3>

<p>可惜的是，系统中重要的数据载体是cbo，由工具生成的，类似于vo。所以cbo没什么像样的行为。 <br/>
对于开发java web的同学，习惯cbo,mvc这样的流水线作业，使用面向对象编程，对封装行为并不习惯。<br/>
引用郑大的话:我们需要更好的封装，通常的做法是封装出行为。行为从哪来，从实际需求来。<br/>
所以，还是得在平时工作中有意识、有针对性的实践才行呀!</p>

<p>{% assign series_list = "improve bitter code" %}
{% include series_list.html %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[improve bitter code: 看不懂的正则表达式]]></title>
    <link href="http://mccxj.github.com/blog/20120728_improve-bitter-code-3.html"/>
    <updated>2012-07-28T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/improve-bitter-code-3</id>
    <content type="html"><![CDATA[<p><strong>备注: 示例中的代码并不是真实代码的完全拷贝</strong></p>

<h3>偶然的发现</h3>

<p>今天好奇浏览了一下N项目的代码变更历史，发现有人提交了一段关于校验文件格式的代码。
其中包括一段校验日期格式的java代码。代码是这样的：
{% highlight java %}
String validDateStr = // read from file lines
String regex = "(([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})(((0[13578]|1[02])(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)(0[1-9]|[12][0-9]|30))|(02(0[1-9]|[1][0-9]|2[0-8]))))|((([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))0229)";
if(validDateStr.matches(regex)){</p>

<pre><code>// do something
</code></pre>

<p>}
{% endhighlight %}</p>

<p>看到这个正则表达式，我立马纠结了，这个正则表达式不知是什么意思。
虽然前几天写代码的同事来问过怎么写校验日期的正则，我当时比较忙，叫他找找有没有现成的。
这次看到这个正则，还是被雷了一把。</p>

<p>于是我问了一下，原来这个正则是校验日期格式，不过加了闰年的判断，所以变得相当复杂。
我晚上还去搜了一下，大概是出自<a href="http://www.cnblogs.com/mgod/archive/2007/04/26/728628.html">这里</a>的吧！不同的是文中判断的是YYYY-MM-DD的格式，而同事的代码
是判断YYYYMMDD的格式，显得更为难懂。</p>

<h3>保持代码的可读性、可维护性</h3>

<p>对于这种拿来的复杂代码，的确很cool，不过即使今天你看懂了，别人不一定看得懂，也难保过些日子自己也看不懂了。</p>

<p>所以通常需要一些保持代码可读性、可维护性的手段：
1. 加多几段注释,或者把来源url标注一下，就像有人喜欢标注那个需求一样。
2. 把正则弄成常量，并把验证方法封装起来，只需调用method就可以了。
3. 选择另外一种比较清晰的实现方式, another way, 或许有惊喜。</p>

<p>应该说，这几种情况都应该考虑一下，例如对于上面的例子来说，要使用这么复杂的正则，加上一些简单的注释
是相当有必要的，至少要说明你是想验证什么样的格式。更进一步，封装到方法里边去，例如
{% highlight java %}
public static boolean isStrictYYYYMMDD(String datestr){</p>

<pre><code>return datestr.matches(STRICT_YYYYMMDD_REGEX);
</code></pre>

<p>}
{% endhighlight %}
不过这里有个缺点，只能校验一种日期格式，因为日期格式不像邮箱地址，它的形式多样，这样处理能得到的收益并不是很高。
如果我们可以传递校验日期的格式就更好了。</p>

<h3>换个实现方式</h3>

<p>换个思路，如果不使用正则表达式会怎样，例如<a href="http://docs.oracle.com/javase/1.4.2/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat</a>就提供了严格验证的格式，示例代码如下：
{% highlight java %}
public static boolean isStrictYYYYMMDD(String datestr){</p>

<pre><code>SimpleDateFormat format = new SimpleDateFormat("yyyyMMdd");  
//设置为严格验证模式
format.setLenient(false);
try{
    format.parse(str);
    return true;
} catch (ParseException e) {
    // ignore exeeption
}
return false;
</code></pre>

<p>}
{% endhighlight %}
如果没有设置为严格验证模式的话，20090230这种日期就会变成20090302。</p>

<p>相对于上面正则的方式来说，代码是多了几行，但是因为格式可以变，灵活性有所提高，代码也容易理解了。
另外一方面，由于SimpleDateFormat非线程安全，必须每次都定义一个，在多次处理的情况下显得有些多余。
当然有个折中的方法就是由客户端代码构造format作为传输传递，这样做还有个好处就是，验证日期格式的方法完全就是通用的。</p>

<p>例如，我们可以提供下面的api和调用方式:
{% highlight java %}
//client
SimpleDateFormat format = // 由客户端代码构建format
boolean isDate = DateUtil.isDateFormat(datestr, format);</p>

<p>//DateUtil api
boolean isDateFormat(String datestr, SimpleDateFormat format);
boolean isDateFormat(String datestr, String formatstr);//单次调用
boolean isStrictDateFormat(String datestr, String formatstr);//单次使用,用于严格处理
{% endhighlight %}</p>

<p>在不改变接口的情况下，最初的代码可以调整成以下形式
{% highlight java %}
public static boolean isStrictYYYYMMDD(String datestr){</p>

<pre><code>return isStrictDateFormat(datestr, DateUtil.YYYYMMDD);
</code></pre>

<p>}
{% endhighlight %}</p>

<h3>总结</h3>

<ol>
<li>隐藏某些复杂的细节是必要的，提供的接口要simple, clear。</li>
<li>封装有助于焦距局部代码，即使要更换实现方式，也更加easy。</li>
<li>可以提供通用可定制接口和常用特殊化接口,方便client调用。</li>
<li><a href="http://commons.apache.org/lang/api-2.5/org/apache/commons/lang/time/DateUtils.html">commons-lang</a>和<a href="http://joda-time.sourceforge.net/">joda-time</a>开源库提供了非常成熟的解决方案。</li>
</ol>


<p>{% assign series_list = "improve bitter code" %}
{% include series_list.html %}</p>
]]></content>
  </entry>
  
</feed>
