<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 数独 | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/shu-du/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2013-03-10T22:33:16+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[数独(sudoku)游戏]]></title>
    <link href="http://mccxj.github.com/blog/20120710_sudoku.html"/>
    <updated>2012-07-10T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/sudoku</id>
    <content type="html"><![CDATA[<h3>数独游戏</h3>

<p>在9×9格的大九宫格中有9个3×3格的小九宫格，并提供17个以上的数字。
根据这些数字，利用逻辑和推理，在其它的空格上填入1到9的数字。
每个数字在每个小九宫格内只能出现一次，每个数字在每行、每列也只能出现一次。</p>

<h3>思路与数据结构</h3>

<p>使用回溯法来不断尝试就可以了，可以用一个二维数组来arr[9][9]表示整个数独，其中还没有填上的用0表示。
我们还需要有个方法来判断能否在[i,j]这个格子上填入某个值。
同样还需要一个变量来表示是否已经找到解。另外，我使用了mark(0~80)作为每个格子的序号，
深度搜索的时候就从0开始处理，直到mark=80的时候出现一个解。</p>

<h3>ruby代码示例</h3>

<p>{% highlight ruby %}</p>

<h1>判断能否在[i,j]上填入val</h1>

<p>def is_ok?(i,j,val)
  (0..8).each do |m|</p>

<pre><code>return false if @arr[i][m] == val &amp;&amp; m!=j #判断行不重复
return false if @arr[m][j] == val &amp;&amp; m!=i #判断列不重复
</code></pre>

<p>  end
  (i-i%3..i-i%3+2).each do |m|</p>

<pre><code>(j-j%3..j-j%3+2).each do |n|
  return false if @arr[m][n] == val &amp;&amp; i!=m &amp;&amp; j!=n #判断小九宫格不重复
end
</code></pre>

<p>  end
  true
end</p>

<h1>用来输出数独</h1>

<p>def print; (0..8).each { |m| p @arr[m] }; end</p>

<h1>用来表示是否找到解</h1>

<p>@ok = false</p>

<h1>处理序号为mark开始的格子</h1>

<p>def walk(mark)
  m, n = mark/9, mark%9
  val = @arr[m][n]
  # 当前已经有初始值的情况
  if val != 0</p>

<pre><code>mark == 80 ? @ok = true : walk(mark+1)
return
</code></pre>

<p>  end</p>

<p>  # 没有初始值的情况
  (1..9).each do |v|</p>

<pre><code>if is_ok?(m, n, v)
  @arr[m][n] = v
  @ok = true and return if mark==80 # 找到一个解
  walk(mark+1) #填好值之后，继续深度搜索
  return if @ok
end
</code></pre>

<p>  end
  @arr[m][n]=0 # 都处理完，没有找到就恢复
end</p>

<p>walk(0)
@ok ? print : (p "no solution")
{% endhighlight %}</p>

<h3>回溯法的基本步骤：</h3>

<ol>
<li>a定义问题的解空间</li>
<li>a确定易于搜索的解空间结构</li>
<li>a以深度优先搜索的策略搜索解空间，并在搜索过程中用剪枝函数避免无效搜索</li>
</ol>


<h3>回溯法的基本结构</h3>

<p>我们考虑递归的方式(比较容易理解)，递推的以后再讨论。
{% highlight ruby %}</p>

<h1>init</h1>

<p>flag = false # 标记是否找到解
u = {} # 已知解, 并假设(x1,x2....xn)为可选的解空间</p>

<p>def backtrack(k)
  (x1..xn).each do |x|</p>

<pre><code>if is_ok?(x, k) # 过滤无效的解
  u.add(x) # 把x加入已知解u
  backtrack(k+1) if u.is_part? # 部分解的情况，继续处理
  flag = true and exit if u.is_full? # 找到解并退出
  # fail的时候有可能需要对u进行恢复
end
</code></pre>

<p>  end
  # fail的时候有可能需要对u进行恢复
end</p>

<p>backtrack(1) # 从1开始搜索
flag ? p u : "no solution"
{% endhighlight %}</p>
]]></content>
  </entry>
  
</feed>
